{% extends "hr/_base.html" %}

{% block title %}Notifications â€¢ HR{% endblock %}

{% block content %}
<style>
/* Ensure critical action buttons are clickable even if overlays exist */
.ensure-top { position: relative !important; z-index: 999999 !important; pointer-events: auto !important; }
</style>
<header class="card rounded-2xl bg-gray-900/80 p-3 sm:p-4 md:p-5 mb-4 sm:mb-6 border border-gray-800">
  <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3 sm:gap-4">
    <div>
      <h1 class="text-xl sm:text-2xl md:text-3xl font-bold text-white">Notifications</h1>
      <p class="text-gray-400 text-xs sm:text-sm">Branch-scoped applicant updates</p>
    </div>
    <div class="flex items-center gap-3">
      <div class="text-right">
        <p class="text-xs text-gray-500">Unread</p>
        <p class="text-lg font-bold text-red-400" id="unread-count">{{ unread_count }}</p>
      </div>
      {% if unread_count > 0 %}
      <form id="mark-all-read-form" action="{{ url_for('mark_all_hr_notifications_read') }}" method="POST" class="inline">
        <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
        <button type="submit" class="px-3 sm:px-4 py-2 text-xs sm:text-sm bg-red-600 hover:bg-red-700 text-white rounded-lg font-semibold flex items-center gap-2 transition-all">
          <i class="fas fa-check-double"></i>
          <span>Mark All as Read</span>
        </button>
      </form>
      {% endif %}
      {% if notifications %}
      <form id="delete-all-form" action="{{ url_for('delete_all_hr_notifications') }}" method="POST" class="inline">
        <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
        <button type="submit" onclick="event.preventDefault(); confirmAndSubmitForm(this.closest('form'), 'Delete all notifications? This cannot be undone.');" class="ensure-top px-3 sm:px-4 py-2 text-xs sm:text-sm bg-red-600/20 text-red-300 hover:text-white hover:bg-red-600/30 rounded-lg border border-red-600/30 hover:border-red-600/50 transition-all flex items-center gap-2">
          <i class="fas fa-trash"></i>
          <span>Delete All</span>
        </button>
      </form>
      {% endif %}
    </div>
  </div>
</header>

{% if notifications %}
<section class="card rounded-2xl bg-gray-900/80 p-3 sm:p-4 border border-gray-800">
  <div class="space-y-3" id="notifications-list">
    {% for notif in notifications %}
    <div class="notification-item border border-gray-800 rounded-xl p-3 sm:p-4 transition-all duration-200 {% if not notif.is_read %}bg-gray-800/50 border-l-4 border-l-red-500{% else %}bg-gray-900/40{% endif %} hover:border-gray-700 hover:shadow-lg" data-notification-id="{{ notif.notification_id }}" data-read="{{ 'true' if notif.is_read else 'false' }}">
      <div class="flex items-start justify-between gap-3">
        <div class="min-w-0 flex-1">
          <div class="flex items-start gap-2">
            <!-- Icon -->
            <div class="flex-shrink-0 mt-1">
              {% if not notif.is_read %}
              <div class="w-2 h-2 rounded-full bg-red-500 animate-pulse"></div>
              {% else %}
              <i class="fas fa-check-circle text-gray-500 text-xs"></i>
              {% endif %}
            </div>
            <!-- Content -->
            <div class="flex-1 min-w-0">
              <p class="text-white font-semibold text-xs sm:text-sm md:text-base {% if not notif.is_read %}font-bold{% endif %}">{{ notif.message }}</p>
              <div class="flex flex-wrap items-center gap-2 text-xs text-gray-400 mt-2">
                {% if notif.job_title and notif.job_title != 'N/A' %}
                <span class="inline-flex items-center gap-1 px-2 py-1 bg-gray-800/50 rounded-md">
                  <i class="fas fa-briefcase text-xs"></i>{{ notif.job_title }}
                </span>
                {% endif %}
                {% if notif.applicant_name and notif.applicant_name != 'Unknown' %}
                <span class="inline-flex items-center gap-1 px-2 py-1 bg-gray-800/50 rounded-md">
                  <i class="fas fa-user text-xs"></i>{{ notif.applicant_name }}
                </span>
                {% endif %}
                {% if notif.application_status %}
                <span class="inline-flex items-center gap-1 px-2 py-1 bg-gray-800/50 rounded-md">
                  <i class="fas fa-tag text-xs"></i>{{ notif.application_status.replace('_', ' ')|title }}
                </span>
                {% endif %}
                <span class="inline-flex items-center gap-1 text-gray-500">
                  <i class="fas fa-clock text-xs"></i>{{ notif.sent_at }}
                </span>
              </div>
            </div>
          </div>
        </div>
        <!-- Actions -->
        <div class="flex-shrink-0 flex items-center gap-2">
          {% if not notif.is_read %}
          <form class="mark-read-form inline" action="{{ url_for('mark_hr_notification_read', notification_id=notif.notification_id) }}" method="POST" data-notification-id="{{ notif.notification_id }}">
            <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
            <button type="submit" class="text-xs px-2 sm:px-3 py-1 sm:py-1.5 bg-red-600/20 text-red-400 hover:bg-red-600/30 rounded-lg border border-red-600/30 hover:border-red-600/50 transition-all flex items-center gap-1.5" title="Mark as Read">
              <i class="fas fa-check text-xs"></i>
              <span class="hidden sm:inline">Mark Read</span>
            </button>
          </form>
          {% else %}
          <span class="text-xs px-2 sm:px-3 py-1 sm:py-1.5 bg-gray-800/50 text-gray-500 rounded-lg border border-gray-700 flex items-center gap-1.5">
            <i class="fas fa-check-circle text-xs"></i>
            <span class="hidden sm:inline">Read</span>
          </span>
          {% endif %}
          <form class="delete-notification-form inline" action="{{ url_for('delete_hr_notification', notification_id=notif.notification_id) }}" method="POST" data-notification-id="{{ notif.notification_id }}">
            <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
            <button type="submit" onclick="event.preventDefault(); confirmAndSubmitForm(this.closest('form'), 'Delete this notification? This cannot be undone.');" class="ensure-top text-xs px-2 sm:px-3 py-1 sm:py-1.5 bg-red-600/20 text-red-400 hover:bg-red-600/30 rounded-lg border border-red-600/30 hover:border-red-600/50 transition-all flex items-center gap-1.5" title="Delete">
              <i class="fas fa-trash text-xs"></i>
              <span class="hidden sm:inline">Delete</span>
            </button>
          </form>
        </div>
      </div>
    </div>
    {% endfor %}
  </div>
</section>
{% else %}
<div class="card rounded-2xl bg-gray-900/80 p-8 sm:p-10 text-center text-gray-400 border border-gray-800">
  <i class="fas fa-bell-slash text-4xl sm:text-5xl mb-3 sm:mb-4 text-gray-600"></i>
  <p class="text-base sm:text-lg font-semibold mb-2">No notifications</p>
  <p class="text-xs sm:text-sm">You'll see applicant updates here as they happen.</p>
</div>
{% endif %}
{% endblock %}

{% block extra_js %}
<script>
document.addEventListener('DOMContentLoaded', () => {
    // Handle mark all as read
    const markAllReadForm = document.getElementById('mark-all-read-form');
    if (markAllReadForm) {
        markAllReadForm.addEventListener('submit', async function(e) {
            e.preventDefault();
            const formData = new FormData(this);
            const submitBtn = this.querySelector('button[type="submit"]');
            const originalHTML = submitBtn.innerHTML;
            
            try {
                submitBtn.disabled = true;
                submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> <span>Processing...</span>';
                
                const response = await fetch(this.action, {
                    method: 'POST',
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest',
                        'Accept': 'application/json'
                    },
                    body: formData
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Update all notification items to read state
                    document.querySelectorAll('.notification-item').forEach(item => {
                        item.classList.remove('bg-gray-800/50', 'border-l-4', 'border-l-red-500');
                        item.classList.add('bg-gray-900/40');
                        item.setAttribute('data-read', 'true');
                        
                        // Update icon
                        const iconDiv = item.querySelector('.flex-shrink-0');
                        if (iconDiv) {
                            iconDiv.innerHTML = '<i class="fas fa-check-circle text-gray-500 text-xs"></i>';
                        }
                        
                        // Update action buttons
                        const markReadForm = item.querySelector('.mark-read-form');
                        if (markReadForm) {
                            markReadForm.outerHTML = '<span class="text-xs px-2 sm:px-3 py-1 sm:py-1.5 bg-gray-800/50 text-gray-500 rounded-lg border border-gray-700 flex items-center gap-1.5"><i class="fas fa-check-circle text-xs"></i><span class="hidden sm:inline">Read</span></span>';
                        }
                    });
                    
                    // Update unread count
                    const unreadCountEl = document.getElementById('unread-count');
                    if (unreadCountEl) {
                        unreadCountEl.textContent = '0';
                    }
                    
                    // Hide mark all as read button
                    if (markAllReadForm) {
                        markAllReadForm.style.display = 'none';
                    }
                    
                    // Show success message
                    showFlashMessage('All notifications marked as read.', 'success');
                } else {
                    showFlashMessage(data.error || 'Failed to mark all notifications as read.', 'error');
                }
            } catch (error) {
                console.error('Error marking all as read:', error);
                showFlashMessage('Failed to mark all notifications as read.', 'error');
            } finally {
                submitBtn.disabled = false;
                submitBtn.innerHTML = originalHTML;
            }
        });
    }
    
    // Handle individual mark as read
    document.querySelectorAll('.mark-read-form').forEach(form => {
        form.addEventListener('submit', async function(e) {
            e.preventDefault();
            const formData = new FormData(this);
            const notificationItem = this.closest('.notification-item');
            const notificationId = this.getAttribute('data-notification-id');
            const submitBtn = this.querySelector('button[type="submit"]');
            
            try {
                submitBtn.disabled = true;
                
                const response = await fetch(this.action, {
                    method: 'POST',
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest',
                        'Accept': 'application/json'
                    },
                    body: formData
                });
                
                const data = await response.json();
                
                if (data.success && notificationItem) {
                    // Update notification item to read state
                    notificationItem.classList.remove('bg-gray-800/50', 'border-l-4', 'border-l-red-500');
                    notificationItem.classList.add('bg-gray-900/40');
                    notificationItem.setAttribute('data-read', 'true');
                    
                    // Update icon
                    const iconDiv = notificationItem.querySelector('.flex-shrink-0');
                    if (iconDiv) {
                        iconDiv.innerHTML = '<i class="fas fa-check-circle text-gray-500 text-xs"></i>';
                    }
                    
                    // Replace mark read button with read indicator
                    this.outerHTML = '<span class="text-xs px-2 sm:px-3 py-1 sm:py-1.5 bg-gray-800/50 text-gray-500 rounded-lg border border-gray-700 flex items-center gap-1.5"><i class="fas fa-check-circle text-xs"></i><span class="hidden sm:inline">Read</span></span>';
                    
                    // Update unread count
                    const unreadCountEl = document.getElementById('unread-count');
                    if (unreadCountEl) {
                        const currentCount = parseInt(unreadCountEl.textContent) || 0;
                        const newCount = Math.max(0, currentCount - 1);
                        unreadCountEl.textContent = newCount;
                        
                        // Hide mark all as read button if no unread notifications
                        if (newCount === 0 && markAllReadForm) {
                            markAllReadForm.style.display = 'none';
                        }
                    }
                } else {
                    showFlashMessage(data.error || 'Failed to mark notification as read.', 'error');
                }
            } catch (error) {
                console.error('Error marking notification as read:', error);
                showFlashMessage('Failed to mark notification as read.', 'error');
            } finally {
                submitBtn.disabled = false;
            }
        });
    });
    
    // Handle delete notification
    document.querySelectorAll('.delete-notification-form').forEach(form => {
        form._hasDeleteHandler = true;
        form.addEventListener('submit', function(e) {
            e.preventDefault();
            const formEl = this;
            openConfirmWithCallback(async function() {
                const formData = new FormData(formEl);
                const notificationItem = formEl.closest('.notification-item');
                const notificationId = formEl.getAttribute('data-notification-id');
                const submitBtn = formEl.querySelector('button[type="submit"]');
                const wasUnread = notificationItem && notificationItem.getAttribute('data-read') === 'false';

                try {
                    submitBtn.disabled = true;
                    submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin text-xs"></i>';

                    const response = await fetch(formEl.action, {
                        method: 'POST',
                        headers: {
                            'X-Requested-With': 'XMLHttpRequest',
                            'Accept': 'application/json'
                        },
                        body: formData
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(errorText || `HTTP error! status: ${response.status}`);
                    }

                    const contentType = response.headers.get('content-type') || '';
                    let data;
                    if (contentType.includes('application/json')) {
                        try { data = await response.json(); } catch { data = { success: true }; }
                    } else { data = { success: true }; }

                    if (data.success && notificationItem) {
                        showFlashMessage('Notification deleted successfully.', 'success');
                        notificationItem.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                        notificationItem.style.opacity = '0';
                        notificationItem.style.transform = 'translateX(-20px)';

                        setTimeout(() => {
                            notificationItem.remove();
                            const notificationsList = document.getElementById('notifications-list');
                            if (notificationsList && notificationsList.children.length === 0) {
                                window.location.reload();
                            }
                        }, 300);

                        if (wasUnread) {
                            const unreadCountEl = document.getElementById('unread-count');
                            if (unreadCountEl) {
                                const currentCount = parseInt(unreadCountEl.textContent) || 0;
                                const newCount = Math.max(0, currentCount - 1);
                                unreadCountEl.textContent = newCount;
                                if (newCount === 0 && markAllReadForm) markAllReadForm.style.display = 'none';
                            }
                        }
                    } else {
                        showFlashMessage(data.error || data.message || 'Failed to delete notification.', 'error');
                        submitBtn.disabled = false;
                        submitBtn.innerHTML = '<i class="fas fa-trash text-xs"></i> <span class="hidden sm:inline">Delete</span>';
                    }
                } catch (error) {
                    console.error('Error deleting notification:', error);
                    showFlashMessage('Failed to delete notification.', 'error');
                    submitBtn.disabled = false;
                    submitBtn.innerHTML = '<i class="fas fa-trash text-xs"></i> <span class="hidden sm:inline">Delete</span>';
                }
            }, 'Delete this notification? This cannot be undone.');
        });
    });
    
    // Handle delete all notifications
    const deleteAllForm = document.getElementById('delete-all-form');
    if (deleteAllForm) {
        deleteAllForm.addEventListener('submit', function(e) {
            e.preventDefault();
            const formEl = this;
            openConfirmWithCallback(async function() {
                const formData = new FormData(formEl);
                const submitBtn = formEl.querySelector('button[type="submit"]');
                const originalHTML = submitBtn.innerHTML;

                try {
                    submitBtn.disabled = true;
                    submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> <span>Deleting...</span>';

                    const response = await fetch(formEl.action, {
                        method: 'POST',
                        headers: {
                            'X-Requested-With': 'XMLHttpRequest',
                            'Accept': 'application/json'
                        },
                        body: formData
                    });

                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

                    const contentType = response.headers.get('content-type') || '';
                    let data;
                    if (contentType.includes('application/json')) data = await response.json(); else data = { success: true };

                    if (data.success) {
                        showFlashMessage('All notifications deleted successfully.', 'success');
                        setTimeout(() => { window.location.reload(); }, 1000);
                    } else {
                        showFlashMessage(data.error || data.message || 'Failed to delete all notifications.', 'error');
                        submitBtn.disabled = false;
                        submitBtn.innerHTML = originalHTML;
                    }
                } catch (error) {
                    console.error('Error deleting all notifications:', error);
                    showFlashMessage('Failed to delete all notifications. Please try again.', 'error');
                    submitBtn.disabled = false;
                    submitBtn.innerHTML = originalHTML;
                }
            }, 'Delete all notifications? This cannot be undone.');
        });
    }
    
    // Helper function to show flash messages
    function showFlashMessage(message, type) {
        const flashContainer = document.createElement('div');
        flashContainer.className = `fixed top-4 right-4 z-50 px-4 py-3 rounded-lg shadow-lg flex items-center gap-2 ${
            type === 'success' ? 'bg-green-600 text-white' : 'bg-red-600 text-white'
        }`;
        flashContainer.innerHTML = `
            <i class="fas fa-${type === 'success' ? 'check-circle' : 'exclamation-circle'}"></i>
            <span>${message}</span>
        `;
        document.body.appendChild(flashContainer);
        
        setTimeout(() => {
            flashContainer.style.transition = 'opacity 0.3s ease';
            flashContainer.style.opacity = '0';
            setTimeout(() => flashContainer.remove(), 300);
        }, 3000);
    }
});
</script>
<script>
// Aggressive capture-phase pointer handler to activate delete buttons when overlays intercept clicks
(function(){
  function ensureBtnStyles(btn){
    try{
      btn.style.setProperty('z-index','999999','important');
      btn.style.setProperty('position', btn.style.position || 'relative','important');
      btn.style.setProperty('pointer-events','auto','important');
    }catch(e){}
  }

  function tryActivateAt(x,y){
    try{
      const els = document.elementsFromPoint(x,y) || [];
      for(const el of els){
        if(!el) continue;
        const bt = el.closest && el.closest('button.ensure-top, .delete-notification-form button[type="submit"], #delete-all-form button[type="submit"]');
        if(bt){
          ensureBtnStyles(bt);
          // call confirm helper directly
          const form = bt.closest('form');
          if(form){
            confirmAndSubmitForm(form, bt.dataset.confirmMessage || bt.getAttribute('data-confirm') || 'Delete?');
            return true;
          }
        }
      }
    }catch(e){ console.error('tryActivateAt error', e); }
    return false;
  }

  ['pointerdown','touchstart','mousedown'].forEach(evName => {
    window.addEventListener(evName, function(e){
      try{
        const x = e.touches && e.touches[0] ? e.touches[0].clientX : e.clientX;
        const y = e.touches && e.touches[0] ? e.touches[0].clientY : e.clientY;
        if(!x && !y) return;
        // Run tryActivateAt asynchronously to avoid interfering with other capture handlers
        setTimeout(() => { tryActivateAt(x,y); }, 0);
      }catch(err){ /* ignore */ }
    }, { capture: true, passive: true });
  });

  // Immediate pointerdown capture (non-passive) to intercept before overlays consume
  window.addEventListener('pointerdown', function(e){
    try{
      const x = e.clientX, y = e.clientY;
      if(!x && !y) return;
      const activated = tryActivateAt(x,y);
      if(activated){
        try{ e.preventDefault(); e.stopPropagation(); } catch(_){}
      }
    }catch(err){}
  }, { capture: true, passive: false });

  // Force-important styles on existing buttons on load
  document.addEventListener('DOMContentLoaded', function(){
    try{
      document.querySelectorAll('.ensure-top, .delete-notification-form button[type="submit"], #delete-all-form button[type="submit"]').forEach(b => ensureBtnStyles(b));
    }catch(e){}
  });
})();
</script>
<script>
document.addEventListener('DOMContentLoaded', function() {
  try {
    document.querySelectorAll('.delete-notification-form button[type="submit"]').forEach(btn => {
      btn.addEventListener('click', function() {
        const form = this.closest('.delete-notification-form');
        if (form && typeof openConfirmWithCallback === 'function') {
          if (!form._hasDeleteHandler) {
            form._hasDeleteHandler = true;
            form.addEventListener('submit', function(subE) {
              subE.preventDefault();
              openConfirmWithCallback(async function() {
                form.submit();
              }, 'Delete this notification? This cannot be undone.');
            }, { passive: false });
          }
        }
      });
    });
  } catch (err) { console.error('Delete button fallback init error', err); }
});
</script>
<script>
// Helper fallback used by inline onclick attributes to ensure confirmation works
function confirmAndSubmitForm(form, msg) {
  try {
    if (!form) return;
    if (typeof openConfirmWithCallback === 'function') {
      openConfirmWithCallback(function() { form.submit(); }, msg || 'Are you sure?');
      return;
    }
  } catch (e) {
    console.error('confirmAndSubmitForm error', e);
  }
  // Fallback to native confirm
  if (confirm(msg || 'Are you sure?')) {
    form.submit();
  }
}
</script>
<script>
// Force ensure-top buttons to be clickable and route clicks to confirmation helper
document.addEventListener('DOMContentLoaded', function() {
  try {
    document.querySelectorAll('.ensure-top').forEach(btn => {
      // Force styles to be on top
      try {
        btn.style.zIndex = '99999';
        if (!btn.style.position) btn.style.position = 'relative';
        btn.style.pointerEvents = 'auto';
      } catch(e) {}

      // Prevent other overlays from swallowing clicks
      btn.addEventListener('click', function(ev) {
        try {
          ev.stopPropagation();
          ev.preventDefault();
          const form = this.closest('form');
          if (form) {
            confirmAndSubmitForm(form, this.dataset.confirmMessage || this.getAttribute('data-confirm') || 'Delete this notification? This cannot be undone.');
          }
        } catch(err) { console.error('ensure-top click handler error', err); }
      }, { passive: false });
    });

    // As a fallback, ensure delete-notification-form buttons also route to confirm helper
    document.querySelectorAll('.delete-notification-form').forEach(form => {
      if (form._addedFallback) return;
      form._addedFallback = true;
      const btn = form.querySelector('button[type="submit"]');
      if (btn) {
        btn.addEventListener('click', function(e) {
          try {
            e.stopPropagation();
            e.preventDefault();
            confirmAndSubmitForm(form, 'Delete this notification? This cannot be undone.');
          } catch(err) { console.error('delete btn fallback', err); }
        }, { passive: false });
        // ensure it's on top
        try { btn.style.zIndex = '99999'; btn.style.pointerEvents = 'auto'; } catch(e) {}
      }
    });
  } catch (err) { console.error('ensure-top init error', err); }
});
</script>
<script>
// Ensure no overlay/modal is accidentally blocking interactions on this page
document.addEventListener('DOMContentLoaded', function() {
  try {
    // Sidebar overlay
    const sidebarOverlay = document.getElementById('sidebar-overlay');
    if (sidebarOverlay) {
      sidebarOverlay.classList.remove('active');
            sidebarOverlay.classList.add('hidden');
            sidebarOverlay.style.pointerEvents = 'none';
    }

    // Global confirm modal
    const globalModal = document.getElementById('global-confirm-modal');
    if (globalModal) {
            // Ensure modal is hidden but allow it to be shown later by removing any inline pointer-events block
            globalModal.classList.add('hidden');
            try { globalModal.style.pointerEvents = ''; } catch(e) {}
    }

    // Remove modal-open state if accidentally left
    document.body.classList.remove('modal-open');
    document.body.style.overflow = '';
  } catch (err) {
    console.error('Overlay cleanup error', err);
  }
});
</script>
<script>
// Hide any other modal overlays that might be present on the page (but keep global-confirm-modal operable)
document.addEventListener('DOMContentLoaded', function() {
  try {
    document.querySelectorAll('.modal-overlay').forEach(m => {
      if (!m.id || m.id === 'global-confirm-modal') return;
      m.classList.add('hidden');
      try { m.style.pointerEvents = 'none'; } catch(e) {}
    });
  } catch(e) { console.error('modal-overlay sweep error', e); }
});
</script>
<script>
// Capture-phase click fallback: detect underlying delete buttons even when overlays intercept clicks
document.addEventListener('click', function(e) {
  try {
    if (!e.clientX && !e.clientY) return;
    const x = e.clientX, y = e.clientY;
    const elems = document.elementsFromPoint(x, y) || [];

    // Look for a matching button under the click (ignore overlay elements)
    for (const el of elems) {
      if (!el) continue;
      // direct button match
      if (el.matches && (el.matches('button.ensure-top') || el.matches('.delete-notification-form button[type="submit"]') || el.matches('#delete-all-form button[type="submit"]'))) {
        // find nearest form
        const form = el.closest('form');
        if (form) {
          e.preventDefault();
          e.stopPropagation();
          // Use confirm helper
          confirmAndSubmitForm(form, el.dataset.confirmMessage || el.getAttribute('data-confirm') || 'Delete? This cannot be undone.');
          return;
        }
      }
      // handle if clicked element is an inner icon/span inside button
      const bt = el.closest && el.closest('button.ensure-top, .delete-notification-form button[type="submit"], #delete-all-form button[type="submit"]');
      if (bt) {
        const form = bt.closest('form');
        if (form) {
          e.preventDefault();
          e.stopPropagation();
          confirmAndSubmitForm(form, bt.dataset.confirmMessage || bt.getAttribute('data-confirm') || 'Delete? This cannot be undone.');
          return;
        }
      }
    }
  } catch (err) {
    // swallow errors to avoid breaking page
    // console.error('capture click fallback error', err);
  }
}, true);
</script>
<script>
// DEBUG: log modal/overlay elements and elementsFromPoint at click location
document.addEventListener('DOMContentLoaded', function() {
  try {
    const overlays = Array.from(document.querySelectorAll('.modal-overlay, .sidebar-overlay'));
    console.group('Overlay debug: found ' + overlays.length + ' overlays');
    overlays.forEach((ov, i) => {
      try {
        const cs = window.getComputedStyle(ov);
        console.log(`#${ov.id || '(no-id)'} .modal-overlay[${i}]`, {
          display: cs.display,
          visibility: cs.visibility,
          opacity: cs.opacity,
          pointerEvents: cs.pointerEvents,
          zIndex: cs.zIndex,
          classList: ov.className
        });
      } catch(e) { console.log('overlay read error', e); }
    });
    console.groupEnd();

    // Also add a helper to inspect elements at pointer
    window.__inspectPoint = function(x, y) {
      try {
        const els = document.elementsFromPoint(x, y) || [];
        console.log('elementsFromPoint at', x, y, els.map(el => ({ tag: el.tagName, id: el.id, class: el.className }))); 
        return els;
      } catch(e) { console.error(e); }
    };
    console.log('Overlay debug helper: call __inspectPoint(x,y) in console to see elements at coordinates.');
  } catch(e) { console.error('overlay debug init error', e); }
});
</script>
<script>
// DIRECT-FALLBACK: perform native confirm + fetch for deletes to guarantee operation
document.addEventListener('DOMContentLoaded', function() {
  try {
    // Individual deletes
    document.querySelectorAll('.delete-notification-form').forEach(form => {
      const btn = form.querySelector('button[type="submit"]');
      if (!btn || btn._directAttached) return;
      btn._directAttached = true;
      const originalHTML = btn.innerHTML;
      btn.addEventListener('click', async function(e) {
        e.preventDefault();
        if (!confirm('Delete this notification? This cannot be undone.')) return;
        try {
          btn.disabled = true;
          btn.innerHTML = '<i class="fas fa-spinner fa-spin text-xs"></i>';
          const formData = new FormData(form);
          const resp = await fetch(form.action, {
            method: 'POST',
            headers: { 'X-Requested-With': 'XMLHttpRequest', 'Accept': 'application/json' },
            body: formData
          });
          if (!resp.ok) throw new Error('Network error');
          const ct = resp.headers.get('content-type') || '';
          const data = ct.includes('application/json') ? await resp.json() : { success: true };
          if (data && data.success) {
            const item = form.closest('.notification-item');
            if (item) item.remove();
            showFlashMessage(data.message || 'Notification deleted.', 'success');
          } else {
            showFlashMessage(data.error || 'Failed to delete notification.', 'error');
          }
        } catch (err) {
          console.error('Direct delete error', err);
          showFlashMessage('Failed to delete notification. Please try again.', 'error');
        } finally {
          btn.disabled = false;
          btn.innerHTML = originalHTML;
        }
      }, { passive: false });
    });

    // Delete all
    const deleteAllForm = document.getElementById('delete-all-form');
    if (deleteAllForm && !deleteAllForm._directAttached) {
      deleteAllForm._directAttached = true;
      const btn = deleteAllForm.querySelector('button[type="submit"]');
      if (btn) {
        const originalHTML = btn.innerHTML;
        btn.addEventListener('click', async function(e) {
          e.preventDefault();
          if (!confirm('Delete all notifications? This cannot be undone.')) return;
          try {
            btn.disabled = true;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> <span>Deleting...</span>';
            const formData = new FormData(deleteAllForm);
            const resp = await fetch(deleteAllForm.action, {
              method: 'POST',
              headers: { 'X-Requested-With': 'XMLHttpRequest', 'Accept': 'application/json' },
              body: formData
            });
            if (!resp.ok) throw new Error('Network error');
            const ct = resp.headers.get('content-type') || '';
            const data = ct.includes('application/json') ? await resp.json() : { success: true };
            if (data && data.success) {
              showFlashMessage(data.message || 'All notifications deleted.', 'success');
              setTimeout(() => window.location.reload(), 800);
            } else {
              showFlashMessage(data.error || 'Failed to delete all notifications.', 'error');
              btn.disabled = false; btn.innerHTML = originalHTML;
            }
          } catch (err) {
            console.error('Direct delete-all error', err);
            showFlashMessage('Failed to delete all notifications. Please try again.', 'error');
            btn.disabled = false; btn.innerHTML = originalHTML;
          }
        }, { passive: false });
      }
    }
  } catch (err) { console.error('Direct-fallback init error', err); }
});
</script>
{% endblock %}

